package asint;

import java_cup.runtime.*;
import alex.*;
import asint.*;
import ast.*;
import ast.estructuras.*;
import ast.expresiones.*;
import ast.funciones.*;
import ast.instrucciones.*;
import ast.tipos.*;
import errors.GestionErroresTiny;


scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal TokenValue IDEN, ENT, REAL, 
             MAS, MENOS, POR, DIV, IGUAL, POTENCIA, MOD,
             PAP, PCIERRE, CAP, CCIERRE, LAP, LCIERRE,
             MAYOR, MENOR, MAYORIGUAL, MENORIGUAL, DISTINTO, IGUALDAD,
             COMA, PUNTOYCOMA, DOSPUNTOS, PUNTO,
             AND, OR, NEG,
             INT, VOID, CHAR, FLOAT, BOOL, ENUM, STRING, 
             TRUE, FALSE, CARACTER, CADENA, 
             NEW, REF, 
             WHILE, FOR, IF, ELSIF, ELSE, SWITCH, STRUCT, CASE, BREAK, DEFAULT,
             RETURN, MAIN, PRINT;


non terminal Programa S;
non terminal ListaDefinciones Entrada;
non terminal StructClass Struct ;
non terminal List<DecClass> DentroStruct;
non terminal EnumClass Enumerado;
non terminal List<String> DentroEnumerado;
non terminal Fmain FuncionMain;
non terminal Funcion Funcion;
non terminal List<ParTipoIden> Args;
non terminal List<Expresion> Params;

non terminal Ins Instruccion;
non terminal List<Ins> Instrucciones;
non terminal List<Ins> BloqueInstrucciones;
non terminal DecClass Declaracion;
non terminal AsigClass Asignacion;
non terminal IfClass If; 
non terminal WhileClass While;
non terminal SwitchClass Switch;
non terminal List<CaseSwitch> BloqueCase;
non terminal CaseSwitch Case;
non terminal CaseSwitch Default;
non terminal ReturnClass Return;
non terminal FuncallClass InsLlamadaFuncion;
non terminal PrintClass Print;

non terminal FuncallExp LlamadaFuncion;
non terminal Expresion E0;
non terminal Expresion E1;
non terminal Expresion E2;
non terminal Expresion E3;
non terminal Expresion E4;
non terminal Expresion E5;


non terminal TipoClass Tipo;


// Programa
S ::= Entrada:definiciones FuncionMain:fmain 
      {: RESULT = new Programa(definiciones, fmain):};

Entrada ::=  Entrada:definiciones Struct:str
            {: RESULT = definiciones; definiciones.addStruct(str);:}
            | Entrada:definiciones Enum:en
            {: RESULT = definiciones; definiciones.addEnum(en);:}
            | Entrada:definiciones Funcion:f 
            {: RESULT = definiciones; definiciones.addFuncion(f);:}
            | 
            {: RESULT = new ListaDefinciones():};

// Enumerado
Enumerado ::= ENUM IDEN:nombre IGUAL LAP DentroEnumerado:valores LCIERRE PUNTOYCOMA
      {: RESULT = new EnumClass(nombre.lexema,valores); :};

DentroEnumerado ::= DentroEnumerado:restoValores COMA IDEN:valor
                  {: RESULT = restoValores; restoValores.add(valor.lexema); :}
                  | IDEN:valor
                  {: RESULT = new ArrayList<String>(); RESULT.add(valor.lexema); :};

// Struct
Struct ::= STRUCT IDEN:nombre LAP DentroStruct:valores LCIERRE PUNTOYCOMA
      {: RESULT = new StructClass(nombre.lexema,valores); :};

DentroStruct ::= DentroStruct:resto Declaracion:decl
                  {: RESULT = resto; resto.add(decl); :}
                  | Declaracion:decl
                  {: RESULT = new ArrayList<DecClass>(); RESULT.add(decl); :};


// Tipo de funciones/variables
//************************************* Array, Puntero, String
Tipo ::= INT: id
         {: RESULT = new TipoBasicoClass(id.lexema); :}  
         | VOID: id
         {: RESULT = new TipoBasicoClass(id.lexema); :} 
         | FLOAT: id
         {: RESULT = new TipoBasicoClass(id.lexema); :} 
         | BOOL: id
         {: RESULT = new TipoBasicoClass(id.lexema); :}  
         | CHAR: id
         {: RESULT = new TipoBasicoClass(id.lexema); :}  
         | STRING: id
         {: RESULT = new TipoBasicoClass(id.lexema); :}
         | IDEN: id
         {: RESULT = new TipoEstructuraClass(id.lexema); :};

//Funcion y funcion main
Funcion ::= Tipo:tipo IDEN:nombre PAP Args:args PCIERRE BloqueInstrucciones:ins
      {: RESULT = new Funcion(tipo, nombre.lexema, args, ins); :};

FuncionMain ::= VOID MAIN PAP PCIERRE BloqueInstrucciones:ins
      {: RESULT = new MainFuncion("main", ins); :};

Args ::= Args:args COMA Tipo:t IDEN:iden
            {: RESULT = args; args.add(new ParTipoIden(iden.lexema, t)); :}
            | Tipo:t IDEN:iden 
            {: RESULT = new ArrayList<ParTipoIden>(); RESULT.add(new ParTipoIden(iden.lexema, t)); :}                    


Params ::= Params:params COMA E0:exp 
            {: RESULT = params ; params.add(new Expresion()); :}
            | E0: exp
            {: RESULT = new ArrayList<Expresion>(); RESULT.add(exp); :};

// Instrucciones
BloqueInstrucciones ::= LAP Instrucciones:ins LCIERRE
      {: RESULT = ins; :};

Instrucciones ::= Instrucciones:ins Instruccion:elem
                  {: RESULT = ins; ins.add(elem); :} 
			|
                  {: RESULT = new ArrayList<Ins>(); :};

Instruccion ::= Declaracion:elem 
                  {: RESULT = elem; :}
                  | Asignacion:elem
                  {: RESULT = elem; :}   
                  | If:elem
                  {: RESULT = elem; :}
                  | While:elem 
                  {: RESULT = elem; :}
                  | Switch:elem 
                  {: RESULT = elem; :}
                  | Print:elem
                  {: RESULT = elem; :}
                  | Return:elem
                  {: RESULT = elem; :}
                  | InsLlamadaFuncion:elem
                  {: RESULT = elem; :};



Declaracion ::= Tipo:t IDEN:nombre PUNTOYCOMA 
                {: RESULT = new DecClass(t,nombre.lexema); :}
                | Tipo:t IDEN:nombre IGUAL E0:exp PUNTOYCOMA
                {: RESULT = new DecClass(t,nombre.lexema,exp); :};
// Inicializar structs y enum?

        

Asignacion ::= IDEN:nombre IGUAL E0:exp PUNTOYCOMA
      {: RESULT = new AssigClass(nombre.lexema, exp); :};

If ::= IF PAP E0:exp PCIERRE BloqueInstrucciones:ins
       {: RESULT = new IfClass(exp,ins); :}
       | IF PAP E0:exp PCIERRE BloqueInstrucciones:ins ELSE BloqueInstrucciones:inselse
       {: RESULT = new IfClass(e,ins,inselse); :};
//      | IF PAP E0 PCIERRE BloqueInstrucciones Elsif;
//Elsif ::= ELSIF PAP E0 PCIERRE BloqueInstrucciones Elsif
//         | ELSE BloqueInstrucciones
//         | ;

While ::= WHILE PAP E0:exp PCIERRE BloqueInstrucciones:ins
      {: RESULT = new WhileClass(exp,ins); :} ;                
 

Switch ::= SWITCH PAP E0:exp PCIERRE LAP BloqueCase:casos LCIERRE
      {: RESULT = new SwitchClass(exp,casos); :};

BloqueCase ::= BloqueCase:casos Case:caso  
               {: RESULT = casos; casos.add(caso) :}
               | Default: caso
               {: RESULT = new ArrayList<CaseSwitch>(); RESULT.add(caso) :};   

Case ::= CASE E0:exp DOSPUNTOS Instrucciones:ins BREAK PUNTOYCOMA                            
      {: RESULT = new CaseSwitch(exp,ins); :}; 

Default ::= DEFAULT DOSPUNTOS Instrucciones:ins    
      {: RESULT = new CaseSwitch(ins); :} ; 

Print ::= PRINT PAP E0:exp PCIERRE PUNTOYCOMA
      {: RESULT = new PrintClass(exp); :};

Return ::= RETURN E0:exp PUNTOYCOMA 
            {: RESULT = new ReturnClass(exp); :}
            | RETURN PUNTOYCOMA
            {: RESULT = new ReturnClass(); :};


InsLlamadaFuncion ::= LlamadaFuncion:funcion PUNTOYCOMA
      {: RESULT = new FuncallClass(funcion); :};

LlamadaFuncion ::= IDEN:nombre PAP Params:params PCIERRE
      {: RESULT = new FuncallExp(nombre,params); :}; 


// Expresiones y operadores
E0 ::= E0:expizq POTENCIA E1:expdcha
      {: RESULT = new OpPotencia(expizq,expdcha); :}
      | E1:exp
      {: RESULT = exp; :};

E1 ::= NEG E1:exp
      {: RESULT = new OpNegar(exp); :}
      | MENOS E1:exp
      {: RESULT = new OpCambioSigno(exp); :}
      | POR: por IDEN:iden E1:exp
      {: RESULT = new OpPuntero(iden,exp); :}
      | E2:exp
      {: RESULT = exp; :};

E2 ::= E2:expizq POR E3:expdcha
      {: RESULT = new OpMult(expizq,expdcha); :}
      | E2:expizq DIV E3:expdcha 
      {: RESULT = new OpDiv(expizq,expdcha); :}
      | E3:exp
      {: RESULT = exp; :};

E3 ::= E3:expizq MAYOR E4:expdcha 
      {: RESULT = new OpMayor(expizq,expdcha); :}
      | E3:expizq MENOR E4:expdcha
      {: RESULT = new OpMenor(expizq,expdcha); :}
      | E3:expizq MAYORIGUAL E4:expdcha 
      {: RESULT = new OpMayorigual(expizq,expdcha); :}
      | E3:expizq MENORIGUAL E4:expdcha 
      {: RESULT = new OpMenorigual(expizq,expdcha); :}
      | E3:expizq IGUALDAD E4:expdcha
      {: RESULT = new OpIgualdad(expizq,expdcha); :}
      | E3:expizq DISTINTO E4:expdcha
      {: RESULT = new OpDesigualdad(expizq,expdcha); :}
      | E3:expizq MAS E4:expdcha
      {: RESULT = new OpSuma(expizq,expdcha); :}
      | E3:expizq MENOS E4:expdcha
      {: RESULT = new OpResta(expizq,expdcha); :}
      | E3:expizq MOD E4:expdcha
      {: RESULT = new OpModulo(expizq,expdcha); :}
      | E4:exp
      {: RESULT = exp; :};

E4 ::= E4:expizq AND E5:expdcha
      {: RESULT = new OpAnd(expizq,expdcha); :}
      | E4:expizq OR E5:expdcha
      {: RESULT = new OpOr(expizq,expdcha); :}
      | E5:exp
      {: RESULT = exp; :};

E5 ::= TRUE:cte
      {: RESULT = new Constante(cte.lexema); :}
      | FALSE:cte
      {: RESULT = new Constante(cte.lexema); :}
      | ENT:cte
      {: RESULT = new Constante(cte.lexema); :}
      | REAL:cte
      {: RESULT = new Constante(cte.lexema); :}
      | CARACTER:cte
      {: RESULT = new Constante(cte.lexema); :}
      | CADENA:cte
      {: RESULT = new Constante(cte.lexema); :}
      | IDEN:cte
      {: RESULT = new Constante(cte.lexema); :}
      | LlamadaFuncion: llamada
      {: RESULT = llamada; :}
      | PAP E0:exp PCIERRE
      {: RESULT = exp; :};







