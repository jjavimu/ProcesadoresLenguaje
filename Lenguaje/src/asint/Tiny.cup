package asint;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import errors.GestionErroresTiny;

scan with {: return getScanner().next_token(); :};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal UnidadLexica IDEN, ENT, REAL, MAS,
             MENOS, POR, DIV, IGUAL, POTENCIA,MOD,
             PAP, PCIERRE, CAP, CCIERRE,
             MAYOR, MENOR, MAYORIGUAL, 
             MENORIGUAL, DISTINTO, 
             COMA, PUNTOYCOMA, DOSPUNTOS, IGUALDAD, AND, OR, NEG,
             LAP, LCIERRE, INT, VOID, CHAR, FLOAT, BOOL, ENUM,
             TRUE, FALSE, CARACTER, STRING, NEW, REF, WHILE, FOR,
             IF, ELSIF, ELSE, SWITCH, STRUCT, CASE, BREAK, DEFAULT,
             RETURN, MAIN, PRINT, PUNTO;


non terminal Entrada S;
non terminal Struct Struct ;
non terminal CuerpoStruct DentroStruct;
non terminal EnumClass Enumerado;
non terminal CuerpoEnum DentroEnumerado;
non terminal Fmain FuncionMain;
non terminal Funcion Funcion;
non terminal List<Expresion> Args;
non terminal Funcall LlamadaFuncion;
non terminal List<Expresion> Params;

non terminal Ins Instruccion;
non terminal List<Ins> Instrucciones;
non terminal List<Ins> BloqueInstrucciones;
non terminal Dec Declaracion;
non terminal Asig Asignacion;
non terminal If If; 
//non terminal Elsif;
non terminal While While;
non terminal Switch Switch;
non terminal CuerpoCase BloqueCase;
//non terminal For;
non terminal InsFuncall InsLlamadaFuncion;

non terminal Expresion E0;
non terminal Expresion E1;
non terminal Expresion E2;
non terminal Expresion E3;
non terminal Expresion E4;
non terminal Expresion E5;

non terminal Print Print;
non terminal Return Return;
non terminal Tipo Tipo;

non terminal Identificador Identificador


S ::= S:entrada Bloque: elem
      {: RESULT = entrada; entrada.add(elem); :} 
	|
      {: RESULT = new ArrayList<Ins>(); :};


S:= Enumerado: enum S
            | Struct: struct S  
            | Funcion: fun S  
            | FuncionMain: funmain S 
            | {: RESULT = new Programa(enum,struct,fun,funmain);:};

Enumerado ::= ENUM IDEN:nombre IGUAL LAP DentroEnumerado:valores LCIERRE PUNTOYCOMA
{: RESULT = new EnumClass(nombre,valores); :};

DentroEnumerado ::= DentroEnumerado:restoValores COMA IDEN:valor
                  {: RESULT = restoValores; restoValores.add(valor); :}
                  | IDEN:valor
                  {: RESULT = new ArrayList<Identificador>(); RESULT.add(valor); :};

Struct ::= STRUCT IDEN LAP DentroStruct LCIERRE PUNTOYCOMA
{: RESULT = new StructClass(nombre,valores); :};

DentroStruct ::= DentroStruct:resto Declaracion:decl
                  {: RESULT = resto; resto.add(decl); :}
                  | Declaracion:decl
                  {: RESULT = new ArrayList<Declaracion>(); RESULT.add(decl); :};


Tipo ::= INT: idInt
         {: RESULT = new IntClass(); :}
         | VOID: idVoid 
         {: RESULT = new VoidClass(); :}
         | FLOAT: idFloat
         {: RESULT = new FloatClass(); :}
         | BOOL: idBool
         {: RESULT = new BoolClass(); :}
         | CHAR: idChar
         {: RESULT = new CharClass(); :}
         | STRING: idString
         {: RESULT = new StringClass(); :};

Funcion ::= Tipo:tipo IDEN:nombre PAP Args:args PCIERRE BloqueInstrucciones:ins
{: RESULT = new Funcion(tipo, nombre, args, ins); :};

FuncionMain ::= VOID MAIN PAP PCIERRE BloqueInstrucciones: ins
{: RESULT = new MainFuncion("main", ins); :};

Args ::= Tipo:t IDEN COMA Args:args 
            {: RESULT = args; RESULT.add(new ParTipoIden(iden.lexema(), t)); :}
            | Tipo:t IDEN:iden 
            {: RESULT.add(new ParTipoIden(iden.lexema(), t)); :}
            |   
            {: RESULT = new ArrayList<ParTipoIden>(); :};                    

LlamadaFuncion ::= IDEN:nombre PAP Params:params PCIERRE
{: RESULT = new Funcall(nombre,params); :}; 

Params ::= E0:exp COMA Params:params 
            {: RESULT = params ; RESULT.add(new Expresion()); :}
            | E0: exp
            {: RESULT.add(new Expresion()); :}
            | 
            {: RESULT = new ArrayList<Expresion>(); :};

BloqueInstrucciones ::= LAP Instrucciones:ins LCIERRE
{: RESULT = ins; :};

Instrucciones ::= Instrucciones:ins Instruccion:elem
                  {: RESULT = ins; ins.add(elem); :} 
			|
                  {: RESULT = new ArrayList<Ins>(); :};

Instruccion ::= Declaracion:elem 
                  {: RESULT = elem; :}
                  | Asignacion:elem
                  {: RESULT = elem; :}   
                  | If:elem
                  {: RESULT = elem; :}
                  | While:elem 
                  {: RESULT = elem; :}
                  | Switch:elem 
                  {: RESULT = elem; :}
                  | Print:elem
                  {: RESULT = elem; :}
                  | Return:elem
                  {: RESULT = elem; :}
                  | InsLlamadaFuncion:elem
                  {: RESULT = elem; :};


InsLlamadaFuncion ::= LlamadaFuncion PUNTOYCOMA;

Declaracion ::= Tipo IDEN PUNTOYCOMA | Tipo Asignacion | IDEN IDEN PUNTOYCOMA;

Asignacion ::= IDEN IGUAL E0 PUNTOYCOMA;

If ::= IF PAP E0 PCIERRE BloqueInstrucciones
      | IF PAP E0 PCIERRE BloqueInstrucciones ELSE BloqueInstrucciones;
//      | IF PAP E0 PCIERRE BloqueInstrucciones Elsif;
//Elsif ::= ELSIF PAP E0 PCIERRE BloqueInstrucciones Elsif
//         | ELSE BloqueInstrucciones
//         | ;

While ::= WHILE PAP E0 PCIERRE BloqueInstrucciones;



Switch ::= SWITCH PAP IDEN PCIERRE LAP BloqueCase LCIERRE;
BloqueCase ::= CASE E0 DOSPUNTOS Instrucciones BREAK PUNTOYCOMA BloqueCase 
               | DEFAULT DOSPUNTOS Instrucciones;

Print ::= PRINT PAP E0 PCIERRE PUNTOYCOMA;

Return ::= RETURN E0 PUNTOYCOMA | RETURN PUNTOYCOMA;


// Expresiones y operadores
E0 ::= E0 POTENCIA E1 
      | E1;
E1 ::= NEG E1
      | MENOS E1
      | E2;
E2 ::= E2 POR E3 
      | E2 DIV E3 
      | E3;
E3 ::= E3 MAYOR E4 
      | E3 MENOR E4 
      | E3 MAYORIGUAL E4 
      | E3 MENORIGUAL E4 
      | E3 IGUALDAD E4
      | E3 DISTINTO E4
      | E3 MAS E4
      | E3 MENOS E4
      | E3 MOD E4
      | E4;
E4 ::= E4 AND E5
      | E4 OR E5
      | E5;
E5 ::= TRUE
      | FALSE
      | ENT
      | REAL
      | CARACTER
      | STRING
      | IDEN
      | LlamadaFuncion
      | PAP E0 PCIERRE;







